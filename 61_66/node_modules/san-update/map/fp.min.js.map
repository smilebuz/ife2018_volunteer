{"version":3,"sources":["../util.js","../command.js","../update.js","../parseName.js","../shortcut.js","../fp.js"],"names":["clone","target","result","key","find","array","fn","i","length","item","notEmpty","o","hasOwnProperty","indexOf","diffObject","type","oldValue","newValue","arrayDiffObject","spliceIndex","deleteCount","insertions","OMIT_THIS_PROPERTY","availableCommands","container","propertyName","Array","isArray","Error","concat","assert","slice","index","_ref","start","_ref2","items","callback","map","filter","args","reduce","apply","toConsumableArray","extensions","diff","newPropertyValue","oldPropertyValue","changeType","defaults","undefined","factory","value","before","after","availableCommandKeys","Object","keys","withDiff","source","commands","possibleRootCommand","wrapper","commandValue","executeCommand","propertyCommand","availableCommand","patchNewProperties","_executeCommand2","propertyDiff","_executeCommand4","push","_executeCommand6","update","LEFT_SQUARE_BRACKET","charCodeAt","parseName","terms","split","term","propAccessorStart","propAccessorEnd","propAccessorLiteral","test","Function","buildPathObject","path","current","set","$set","$push","unshift","$unshift","pop","$pop","shift","$shift","removeAt","$removeAt","remove","$remove","splice","_len","_key","arguments","$splice","$map","$filter","_len2","_key2","command","$reduce","merge","$merge","$defaults","$apply","omit","$omit","composeBefore","$composeBefore","composeAfter","$composeAfter","applyWith","selectors","dependencies","select","boundFactory","dependency","wrap","shortcut"],"mappings":"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","file":"../fp.min.js","sourcesContent":["/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file utility module\n * @author otakustay\n */\n\nexport let clone = target => {\n    let result = {};\n    /* eslint-disable guard-for-in */\n    for (let key in target) {\n        result[key] = target[key];\n    }\n    /* eslint-enable guard-for-in */\n\n    return result;\n};\n\nexport let find = (array, fn) => {\n    for (let i = 0; i < array.length; i++) {\n        let item = array[i];\n        if (fn(item)) {\n            return item;\n        }\n    }\n\n    return undefined;\n};\n\nexport let notEmpty = o => {\n    if (!o) {\n        return false;\n    }\n\n    for (let key in o) {\n        if (o.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\nexport let indexOf = (array, o) => {\n    for (let i = 0; i < array.length; i++) {\n        if (array[i] === o) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\nexport let diffObject = (type, oldValue, newValue) => {\n    return {\n        $change: type,\n        oldValue: oldValue,\n        newValue: newValue\n    };\n};\n\nexport let arrayDiffObject = (oldValue, newValue, spliceIndex, deleteCount, insertions) => {\n    return {\n        $change: 'change',\n        oldValue: oldValue,\n        newValue: newValue,\n        splice: {\n            index: spliceIndex,\n            deleteCount: deleteCount,\n            insertions: insertions\n        }\n    };\n};\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file all available commands\n * @author otakustay\n */\n\nimport {clone, indexOf, diffObject, arrayDiffObject} from './util';\n\n/**\n * @private\n *\n * 当指令返回这个对象的时候，说明要把这个属性移除\n */\nexport const OMIT_THIS_PROPERTY = {};\n\n/**\n * @private\n */\nexport let availableCommands = {\n    $set(container, propertyName, newValue) {\n        let oldValue = container[propertyName];\n        if (newValue === oldValue) {\n            return [newValue, null];\n        }\n\n        return [\n            newValue,\n            diffObject(container.hasOwnProperty(propertyName) ? 'change' : 'add', oldValue, newValue)\n        ];\n    },\n\n    $push(container, propertyName, item) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $push command on non array object is forbidden.');\n        }\n\n        let newValue = array.concat([item]);\n        return [\n            newValue,\n            arrayDiffObject(array, newValue, array.length, 0, [item])\n        ];\n    },\n\n    $unshift(container, propertyName, item) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $unshift command on non array object is forbidden.');\n        }\n\n        let newValue = [item].concat(array);\n        return [\n            newValue,\n            arrayDiffObject(array, newValue, 0, 0, [item])\n        ];\n    },\n\n    $pop(container, propertyName, assert) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $pop command on non array object is forbidden.');\n        }\n\n        if (array.length && (assert === true || (typeof assert === 'function' && assert(array)))) {\n            let newValue = array.slice(0, -1);\n            return [\n                newValue,\n                arrayDiffObject(array, newValue, array.length, 1, [])\n            ];\n        }\n\n        return [array, null];\n    },\n\n    $shift(container, propertyName, assert) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $shift command on non array object is forbidden.');\n        }\n\n        if (array.length && (assert === true || (typeof assert === 'function' && assert(array)))) {\n            let newValue = array.slice(1);\n            return [\n                newValue,\n                arrayDiffObject(array, newValue, array.length, 1, [])\n            ];\n        }\n\n        return [array, null];\n    },\n\n    $removeAt(container, propertyName, index) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $removeAt command on non array object is forbidden.');\n        }\n\n        if (index >= array.length || index < 0) {\n            return [array, null];\n        }\n\n        let newValue = array.slice(0, index).concat(array.slice(index + 1));\n        return [\n            newValue,\n            arrayDiffObject(array, newValue, index, 1, [])\n        ];\n    },\n\n    $remove(container, propertyName, item) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $removeAt command on non array object is forbidden.');\n        }\n\n        let index = indexOf(array, item);\n\n        if (index === -1) {\n            return [array, null];\n        }\n\n        let newValue = array.slice(0, index).concat(array.slice(index + 1));\n        return [\n            newValue,\n            arrayDiffObject(array, newValue, index, 1, [])\n        ];\n    },\n\n    $splice(container, propertyName, [start, deleteCount, ...items]) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $splice command on non array object is forbidden.');\n        }\n\n        let newValue = array.slice(0, start).concat(items).concat(array.slice(start + deleteCount));\n        return [\n            newValue,\n            arrayDiffObject(array, newValue, start, deleteCount, items)\n        ];\n    },\n\n    $map(container, propertyName, callback) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $map command on non array object is forbidden.');\n        }\n\n        let newValue = array.map(callback);\n        return [\n            newValue,\n            diffObject('change', array, newValue)\n        ];\n    },\n\n    $filter(container, propertyName, callback) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $filter command on non array object is forbidden.');\n        }\n\n        let newValue = array.filter(callback);\n        return [\n            newValue,\n            diffObject('change', array, newValue)\n        ];\n    },\n\n    $reduce(container, propertyName, args) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $reduce command on non array object is forbidden.');\n        }\n\n        // .reduce(callback) : .reduce(callback, initialValue)\n        let newValue = typeof args === 'function' ? array.reduce(args) : array.reduce(...args);\n        return [\n            newValue,\n            diffObject('change', array, newValue)\n        ];\n    },\n\n    $merge(container, propertyName, extensions) {\n        let target = container[propertyName] || {};\n        let newValue = clone(target);\n        let diff = {};\n        for (let key in extensions) {\n            if (extensions.hasOwnProperty(key)) {\n                let newPropertyValue = extensions[key];\n                let oldPropertyValue = target[key];\n                if (newPropertyValue !== oldPropertyValue) {\n                    newValue[key] = newPropertyValue;\n                    let changeType = target.hasOwnProperty(key) ? 'change' : 'add';\n                    diff[key] = diffObject(changeType, oldPropertyValue, newPropertyValue);\n                }\n            }\n        }\n\n        return [newValue, diff];\n    },\n\n    $defaults(container, propertyName, defaults) {\n        let target = container[propertyName];\n        let newValue = clone(target);\n        let diff = {};\n        for (let key in defaults) {\n            if (defaults.hasOwnProperty(key) && newValue[key] === undefined) {\n                newValue[key] = defaults[key];\n                diff[key] = diffObject('add', undefined, defaults[key]);\n            }\n        }\n\n        return [newValue, diff];\n    },\n\n    $apply(container, propertyName, factory) {\n        let newValue = factory(container[propertyName]);\n        return [\n            newValue,\n            diffObject(container.hasOwnProperty(propertyName) ? 'change' : 'add', container[propertyName], newValue)\n        ];\n    },\n\n    $omit(container, propertyName, assert) {\n        let value = container[propertyName];\n\n        if (assert === true || (typeof assert === 'function' && assert(value))) {\n            return [\n                OMIT_THIS_PROPERTY,\n                diffObject('remove', value, undefined)\n            ];\n        }\n\n        return [value, null];\n    },\n\n    $composeBefore(container, propertyName, before) {\n        let fn = container[propertyName];\n\n        if (typeof fn !== 'function') {\n            throw new Error('Usage of $composeBefore command on non function object is forbidden.');\n        }\n\n        if (typeof before !== 'function') {\n            throw new Error('Passing non function object to $composeBefore command is forbidden');\n        }\n\n        let newValue = (...args) => fn(before(...args));\n        return [\n            newValue,\n            diffObject('change', fn, newValue)\n        ];\n    },\n\n    $composeAfter(container, propertyName, after) {\n        let fn = container[propertyName];\n\n        if (typeof fn !== 'function') {\n            throw new Error('Usage of $composeAfter command on non function object is forbidden.');\n        }\n\n        if (typeof after !== 'function') {\n            throw new Error('Passing non function object to $composeAfter command is forbidden');\n        }\n\n        let newValue = (...args) => after(fn(...args));\n        return [\n            newValue,\n            diffObject('change', fn, newValue)\n        ];\n    }\n};\n\n/**\n * @private\n */\nexport let availableCommandKeys = Object.keys(availableCommands);\n\n/**\n * @private\n */\nexport let availableCommandNames = availableCommandKeys.map(key => key.slice(1));\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file update helper module\n * @author otakustay\n */\n\nimport {find, notEmpty} from './util';\nimport {availableCommands, availableCommandKeys, OMIT_THIS_PROPERTY} from './command';\n\n/**\n * 根据提供的指令更新一个对象，返回更新后的新对象及差异对象，原对象不会作任何的修改\n *\n * 现有支持的指令包括：\n *\n * - `$set`：修改指定的属性值\n * - `$push`：向类型为数组的属性尾部添加元素\n * - `$unshift`：向类型为数组的属性头部添加元素\n * - `$pop`：移除类型为数组的属性的尾部元素\n * - `$shift`：移除类型为数组的属性的头部元素\n * - `$removeAt`：移除类型为数组的属性的指定位置的元素\n * - `$remove`：移除类型为数组的属性的指定元素，使用`===`判等且仅移除第一个遇到的元素\n * - `$splice`：通过索引、移除数目、插入元素操作类型为数组的属性\n * - `$map`：对类型为数组的属性进行`map`操作\n * - `$filter`：对类型为数组的属性进行`filter`操作\n * - `$reduce`：对类型为数组的属性进行`reduce`操作\n * - `$merge`：将2个对象进行浅合并（不递归）\n * - `$defaults`：将指定对象的属性值填到原属性为'undefined`的'性上\n * - `$apply`：用一个工厂函数的返回值作为`$set`指令的输入，工厂函数接受属性的旧值作为唯一的参数\n * - `$omit`：用于移除某个属性，传递`boolean`值来确认是否移除（`true`为移除），也可传递一个函数（参数为旧值）用其返回值确认是否移除\n * - `$composeBefore`：组合类型为函数的属性为一个新的函数，新函数首先调用compose提供的函数，随后调用原函数\n * - `$composeAfter`：组合类型为函数的属性为一个新的函数，新函数首先调用原函数，随后调用compose提供的函数\n *\n * 可以在一次更新操作中对不同的属性用不同的指令：\n *\n * ```javascript\n * import {withDiff} from 'san-update';\n *\n * let [newObject, diff] = withDiff(\n *     source,\n *     {\n *         foo: {bar: {$set: 1}},\n *         alice: {$push: 1},\n *         tom: {jack: {$set: {x: 1}}\n *     }\n * );\n * ```\n *\n * @param {Object} source 待更新的对象\n * @param {Object} commands 用于更新的指令\n * @return {[Object, Object]} 返回一个Tuple数组，其中第1项为更新结果，第2项为差异对象\n */\nexport let withDiff = (source, commands) => {\n    // 如果根节点就是个指令，那么直接对输入的对象进行操作，不需要再遍历属性了\n    let possibleRootCommand = find(availableCommandKeys, key => commands.hasOwnProperty(key));\n    if (possibleRootCommand) {\n        let wrapper = {source};\n        let commandValue = commands[possibleRootCommand];\n        return availableCommands[possibleRootCommand](wrapper, 'source', commandValue);\n    }\n\n    // ({string} key) => [newValue, diff]\n    let executeCommand = key => {\n        let propertyCommand = commands[key];\n        let availableCommand = find(availableCommandKeys, key => propertyCommand.hasOwnProperty(key));\n\n        // 找到指令节点后，对当前属性进行更新，\n        // 如果这个节点不代表指令，那么肯定它的某个属性（或子属性）是指令，继续递归往下找\n        return availableCommand\n            ? availableCommands[availableCommand](source, key, propertyCommand[availableCommand])\n            : withDiff(source[key] || {}, propertyCommand);\n    };\n\n    // 因为可能通过指令增加一些原本没有的属性，所以最后还要对`commands`做一次遍历来确保没有漏掉\n    let patchNewProperties = (result, diff) => {\n        for (let key in commands) {\n            if (result.hasOwnProperty(key) || !commands.hasOwnProperty(key)) {\n                continue;\n            }\n\n            let [newValue, propertyDiff] = executeCommand(key);\n            // 理论上因为全是新属性，所以这里的`propertyDiff`不可能是空的\n            diff[key] = propertyDiff;\n\n            if (newValue !== OMIT_THIS_PROPERTY) {\n                result[key] = newValue;\n            }\n        }\n\n        return [result, diff];\n    };\n\n    if (Array.isArray(source)) {\n        let result = [];\n        let diff = {};\n        for (let i = 0; i < source.length; i++) {\n            // 没有对应的指令，自然是不更新的，直接复制过去\n            if (!commands.hasOwnProperty(i)) {\n                result.push(source[i]);\n                continue;\n            }\n\n            let [newValue, propertyDiff] = executeCommand(i);\n            if (notEmpty(propertyDiff)) {\n                diff[i] = propertyDiff;\n            }\n            if (newValue !== OMIT_THIS_PROPERTY) {\n                result.push(newValue);\n            }\n        }\n\n        return patchNewProperties(result, diff);\n    }\n\n    let result = {};\n    let diff = {};\n    for (let key in source) {\n        // 没有对应的指令，自然是不更新的，直接复制过去\n        if (!commands.hasOwnProperty(key)) {\n            result[key] = source[key];\n            continue;\n        }\n\n        let [newValue, propertyDiff] = executeCommand(key);\n        if (notEmpty(propertyDiff)) {\n            diff[key] = propertyDiff;\n        }\n        if (newValue !== OMIT_THIS_PROPERTY) {\n            result[key] = newValue;\n        }\n    }\n\n    return patchNewProperties(result, diff);\n};\n\n/**\n * 根据提供的指令更新一个对象，返回更新后的新对象，原对象不会作任何的修改\n *\n * 具体详情参考`withDiff`的文档\n *\n * ```javascript\n * import {update} from 'san-update';\n *\n * let newObject = withDiff(\n *     source,\n *     {\n *         foo: {bar: {$set: 1}},\n *         alice: {$push: 1},\n *         tom: {jack: {$set: {x: 1}}\n *     }\n * );\n * ```\n *\n * @param {Object} source 待更新的对象\n * @param {Object} commands 用于更新的指令\n * @return {Object} 更新后的对象\n */\nexport let update = (source, commands) => withDiff(source, commands)[0];\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file parse property name\n * @author otakustay\n */\n\nconst LEFT_SQUARE_BRACKET = '['.charCodeAt(0);\n\nexport default source => {\n    if (Array.isArray(source)) {\n        return source;\n    }\n\n    // 这个简易的非状态机的实现是有缺陷的\n    // 比如 a['dd.cc'].b 这种就有问题了，不过我们不考虑这种场景\n    let terms = (source + '').split('.');\n    let result = [];\n\n    for (let i = 0; i < terms.length; i++) {\n        let term = terms[i];\n        let propAccessorStart = term.indexOf('[');\n\n\n        if (propAccessorStart >= 0) {\n            if (propAccessorStart > 0) {\n                result.push(term.slice(0, propAccessorStart));\n                term = term.slice(propAccessorStart);\n            }\n\n            while (term.charCodeAt(0) === LEFT_SQUARE_BRACKET) {\n                let propAccessorEnd = term.indexOf(']');\n                if (propAccessorEnd < 0) {\n                    throw new Error('Property path syntax error: ' + source);\n                }\n\n                let propAccessorLiteral = term.slice(1, propAccessorEnd);\n                if (/^[0-9]+$/.test(propAccessorLiteral)) {\n                    // for number\n                    result.push(+propAccessorLiteral);\n                }\n                else if (/^(['\"])([^\\1]+)\\1$/.test(propAccessorLiteral)) {\n                    // for string literal\n                    result.push((new Function('return ' + propAccessorLiteral))());\n                }\n                else {\n                    throw new Error('Property path syntax error: ' + source);\n                }\n\n                term = term.slice(propAccessorEnd + 1);\n            }\n        }\n        else {\n            result.push(term);\n        }\n    }\n\n    return result;\n};\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file shortcut functions\n * @author otakustay\n */\n\nimport {update} from './update';\nimport parseName from './parseName';\n\nlet buildPathObject = (propertyName, value) => {\n    if (propertyName == null) {\n        return value;\n    }\n\n    let path = parseName(propertyName);\n\n    let result = {};\n    let current = result;\n    for (let i = 0; i < path.length - 1; i++) {\n        current = current[path[i]] = {};\n    }\n    current[path[path.length - 1]] = value;\n    return result;\n};\n\n/**\n * 针对`$set`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Object} 更新后的新对象\n */\nexport let set = (source, path, value) => update(source, buildPathObject(path, {$set: value}));\n\n/**\n * 针对`$push`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Object} 更新后的新对象\n */\nexport let push = (source, path, value) => update(source, buildPathObject(path, {$push: value}));\n\n/**\n * 针对`$unshift`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Object} 更新后的新对象\n */\nexport let unshift = (source, path, value) => update(source, buildPathObject(path, {$unshift: value}));\n\n/**\n * 针对`$pop`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {boolean|Function} assert 用于确认是否要移除属性的判断条件或函数\n * @return {Object} 更新后的新对象\n */\nexport let pop = (source, path, assert) => update(source, buildPathObject(path, {$pop: assert}));\n\n/**\n * 针对`$shift`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {boolean|Function} assert 用于确认是否要移除属性的判断条件或函数\n * @return {Object} 更新后的新对象\n */\nexport let shift = (source, path, assert) => update(source, buildPathObject(path, {$shift: assert}));\n\n/**\n * 针对`$removeAt`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {number} index 需要删除的索引\n * @return {Object} 更新后的新对象\n */\nexport let removeAt = (source, path, index) => update(source, buildPathObject(path, {$removeAt: index}));\n\n/**\n * 针对`$remove`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 需要删除的值\n * @return {Object} 更新后的新对象\n */\nexport let remove = (source, path, value) => update(source, buildPathObject(path, {$remove: value}));\n\n/**\n * 针对`$splice`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {number} start 插入起始位置\n * @param {number} deleteCount 删除的元素个数\n * @param {...*} items 插入的元素\n * @return {Object} 更新后的新对象\n */\nexport let splice = (source, path, start, deleteCount, ...items) => {\n    let args = [start, deleteCount, ...items];\n    return update(source, buildPathObject(path, {$splice: args}));\n};\n\n/**\n * 针对`$map`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} callback 回调函数\n * @return {Object} 更新后的新对象\n */\nexport let map = (source, path, callback) => update(source, buildPathObject(path, {$map: callback}));\n\n/**\n * 针对`$filter`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} callback 回调函数\n * @return {Object} 更新后的新对象\n */\nexport let filter = (source, path, callback) => update(source, buildPathObject(path, {$filter: callback}));\n\n/**\n * 针对`$reduce`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {...*} args 调用`reduce`时的参数，可以为`{Function} callback`或`{Function} callback, {*} initialValue`\n * @return {Object} 更新后的新对象\n */\nexport let reduce = (source, path, ...args) => {\n    let command = args.length === 1 ? {$reduce: args[0]} : {$reduce: args};\n    return update(source, buildPathObject(path, command));\n};\n\n/**\n * 针对`$merge`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Object} 更新后的新对象\n */\nexport let merge = (source, path, value) => update(source, buildPathObject(path, {$merge: value}));\n\n/**\n * 针对`$defaults`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Object} 更新后的新对象\n */\nexport let defaults = (source, path, value) => update(source, buildPathObject(path, {$defaults: value}));\n\n/**\n * 针对`$apply`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} factory 用于生成新值的工厂函数\n * @return {Object} 更新后的新对象\n */\nexport let apply = (source, path, factory) => update(source, buildPathObject(path, {$apply: factory}));\n\n/**\n * 针对`$omit`指令的快捷函数，其中`assert`参数默认值为`true`\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {boolean|Function} assert 用于确认是否要移除属性的判断条件或函数\n * @return {Object} 更新后的新对象\n */\nexport let omit = (source, path, assert = true) => update(source, buildPathObject(path, {$omit: assert}));\n\n/**\n * 针对`$omit`指令的快捷函数，其中`assert`参数默认值为`true`\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} before 包装函数，该函数会在原函数前执行，且返回值传递给原函数作为参数\n * @return {Object} 更新后的新对象\n */\nexport let composeBefore = (source, path, before) => update(source, buildPathObject(path, {$composeBefore: before}));\n\n/**\n * 针对`$omit`指令的快捷函数，其中`assert`参数默认值为`true`\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} after 包装函数，该函数会在原函数后执行，且接收原函数返回值作为参数\n * @return {Object} 更新后的新对象\n */\nexport let composeAfter = (source, path, after) => update(source, buildPathObject(path, {$composeAfter: after}));\n\n/**\n * 支持通过依赖计算属性值的更新快捷函数\n *\n * 此函数仅有快捷方式，在`update`函数时不能使用此指令\n *\n * 此函数必须指定`path`参数，不能直接对对象本身使用\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组\n * @param {Function|Array.<Function>} selectors 用于获取`factory`的依赖参数的函数，每个函数返回一个值作为`factory`的参数\n * @param {Function} factory 用于生成新值的工厂函数，该函数前n个参数是`selectors`参数的返回值，最后一个参数为需要更新的属性的当前值\n * @return {Object} 更新后的新对象\n */\nexport let applyWith = (source, path, selectors, factory) => {\n    if (Array.isArray(selectors)) {\n        let dependencies = selectors.map(select => select(source));\n        let boundFactory = value => factory(...dependencies, value);\n        return apply(source, path, boundFactory);\n    }\n\n    let dependency = selectors(source);\n    let boundFactory = value => factory(dependency, value);\n    return apply(source, path, boundFactory);\n};\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file functional programming module\n * @author otakustay\n */\n\nimport * as shortcut from './shortcut';\n\nlet wrap = fn => (...args) => source => fn(source, ...args);\n\n/**\n * 构建一个针对`$set`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let set = wrap(shortcut.set);\n\n/**\n * 构建一个针对`$push`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let push = wrap(shortcut.push);\n\n/**\n * 构建一个针对`$unshift`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let unshift = wrap(shortcut.unshift);\n\n/**\n * 构建一个针对`$pop`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {boolean|Function} assert 用于确认是否要移除属性的判断条件或函数\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let pop = wrap(shortcut.pop);\n\n/**\n * 构建一个针对`$shift`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {boolean|Function} assert 用于确认是否要移除属性的判断条件或函数\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let shift = wrap(shortcut.shift);\n\n/**\n * 构建一个针对`$removeAt`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {number} index 需要删除的索引\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let removeAt = wrap(shortcut.removeAt);\n\n/**\n * 构建一个针对`$remove`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 需要删除的值\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let remove = wrap(shortcut.remove);\n\n/**\n * 构建一个针对`$splice`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {number} start 插入起始位置\n * @param {number} deleteCount 删除的元素个数\n * @param {...*} items 插入的元素\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let splice = wrap(shortcut.splice);\n\n/**\n * 构建一个针对`$map`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} callback 回调函数\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let map = wrap(shortcut.map);\n\n/**\n * 构建一个针对`$filter`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} callback 回调函数\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let filter = wrap(shortcut.filter);\n\n/**\n * 构建一个针对`$reduce`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {...*} args 调用`reduce`时的参数，可以为`{Function} callback`或`{Function} callback, {*} initialValue`\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let reduce = wrap(shortcut.reduce);\n\n/**\n * 构建一个针对`$merge`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let merge = wrap(shortcut.merge);\n\n/**\n * 构建一个针对`$defaults`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let defaults = wrap(shortcut.defaults);\n\n/**\n * 构建一个针对`$apply`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} factory 用于生成新值的工厂函数\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let apply = wrap(shortcut.apply);\n\n/**\n * 构建一个针对`$omit`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {boolean|Function} assert 用于确认是否要移除属性的判断条件或函数\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let omit = wrap(shortcut.omit);\n\n/**\n * 构建一个针对`$omit`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} before 包装函数，该函数会在原函数前执行，且返回值传递给原函数作为参数\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let composeBefore = wrap(shortcut.composeBefore);\n\n/**\n * 构建一个针对`$omit`指令的更新函数\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} after 包装函数，该函数会在原函数后执行，且接收原函数返回值作为参数\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let composeAfter = wrap(shortcut.composeAfter);\n\n/**\n * 构建一个针对`applyWith`快捷函数的更新对象\n *\n * 此函数在`update`函数时不能使用此指令\n *\n * 此函数必须指定`path`参数，不能直接对对象本身使用\n *\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组\n * @param {Function|Array.<Function>} selectors 用于获取`factory`的依赖参数的函数，每个函数返回一个值作为`factory`的参数\n * @param {Function} factory 用于生成新值的工厂函数，该函数前n个参数是`selectors`参数的返回值，最后一个参数为需要更新的属性的当前值\n * @return {Function} 返回更新函数，该函数接收对象后依据指令进行更新并返回新对象\n */\nexport let applyWith = wrap(shortcut.applyWith);\n"]}