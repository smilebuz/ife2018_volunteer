{"version":3,"sources":["../util.js","../command.js","../update.js","../parseName.js","../shortcut.js","../chain.js","../macro.js"],"names":["clone","target","result","key","find","array","fn","i","length","item","notEmpty","o","hasOwnProperty","indexOf","diffObject","type","oldValue","newValue","arrayDiffObject","spliceIndex","deleteCount","insertions","OMIT_THIS_PROPERTY","availableCommands","container","propertyName","Array","isArray","Error","concat","assert","slice","index","_ref","start","_ref2","items","callback","map","filter","args","reduce","apply","toConsumableArray","extensions","diff","newPropertyValue","oldPropertyValue","changeType","defaults","undefined","factory","value","before","after","availableCommandKeys","Object","keys","availableCommandNames","withDiff","source","commands","possibleRootCommand","wrapper","commandValue","executeCommand","propertyCommand","availableCommand","patchNewProperties","_executeCommand2","propertyDiff","_executeCommand4","push","_executeCommand6","update","LEFT_SQUARE_BRACKET","charCodeAt","parseName","terms","split","term","propAccessorStart","propAccessorEnd","propAccessorLiteral","test","Function","buildPathObject","path","current","set","$set","$push","unshift","$unshift","pop","$pop","shift","$shift","removeAt","$removeAt","remove","$remove","splice","_len","_key","arguments","$splice","$map","$filter","_len2","_key2","command","$reduce","merge","$merge","$defaults","$apply","omit","$omit","composeBefore","$composeBefore","composeAfter","$composeAfter","applyWith","selectors","dependencies","select","boundFactory","dependency","EMPTY_COMMANDS","createUpdater","updater","shortcut","additionCommand","newCommands","chain","createMacro","macro","INITIAL_MACRO"],"mappings":"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","file":"../index.min.js","sourcesContent":["/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file utility module\n * @author otakustay\n */\n\nexport let clone = target => {\n    let result = {};\n    /* eslint-disable guard-for-in */\n    for (let key in target) {\n        result[key] = target[key];\n    }\n    /* eslint-enable guard-for-in */\n\n    return result;\n};\n\nexport let find = (array, fn) => {\n    for (let i = 0; i < array.length; i++) {\n        let item = array[i];\n        if (fn(item)) {\n            return item;\n        }\n    }\n\n    return undefined;\n};\n\nexport let notEmpty = o => {\n    if (!o) {\n        return false;\n    }\n\n    for (let key in o) {\n        if (o.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\nexport let indexOf = (array, o) => {\n    for (let i = 0; i < array.length; i++) {\n        if (array[i] === o) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\nexport let diffObject = (type, oldValue, newValue) => {\n    return {\n        $change: type,\n        oldValue: oldValue,\n        newValue: newValue\n    };\n};\n\nexport let arrayDiffObject = (oldValue, newValue, spliceIndex, deleteCount, insertions) => {\n    return {\n        $change: 'change',\n        oldValue: oldValue,\n        newValue: newValue,\n        splice: {\n            index: spliceIndex,\n            deleteCount: deleteCount,\n            insertions: insertions\n        }\n    };\n};\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file all available commands\n * @author otakustay\n */\n\nimport {clone, indexOf, diffObject, arrayDiffObject} from './util';\n\n/**\n * @private\n *\n * 当指令返回这个对象的时候，说明要把这个属性移除\n */\nexport const OMIT_THIS_PROPERTY = {};\n\n/**\n * @private\n */\nexport let availableCommands = {\n    $set(container, propertyName, newValue) {\n        let oldValue = container[propertyName];\n        if (newValue === oldValue) {\n            return [newValue, null];\n        }\n\n        return [\n            newValue,\n            diffObject(container.hasOwnProperty(propertyName) ? 'change' : 'add', oldValue, newValue)\n        ];\n    },\n\n    $push(container, propertyName, item) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $push command on non array object is forbidden.');\n        }\n\n        let newValue = array.concat([item]);\n        return [\n            newValue,\n            arrayDiffObject(array, newValue, array.length, 0, [item])\n        ];\n    },\n\n    $unshift(container, propertyName, item) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $unshift command on non array object is forbidden.');\n        }\n\n        let newValue = [item].concat(array);\n        return [\n            newValue,\n            arrayDiffObject(array, newValue, 0, 0, [item])\n        ];\n    },\n\n    $pop(container, propertyName, assert) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $pop command on non array object is forbidden.');\n        }\n\n        if (array.length && (assert === true || (typeof assert === 'function' && assert(array)))) {\n            let newValue = array.slice(0, -1);\n            return [\n                newValue,\n                arrayDiffObject(array, newValue, array.length, 1, [])\n            ];\n        }\n\n        return [array, null];\n    },\n\n    $shift(container, propertyName, assert) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $shift command on non array object is forbidden.');\n        }\n\n        if (array.length && (assert === true || (typeof assert === 'function' && assert(array)))) {\n            let newValue = array.slice(1);\n            return [\n                newValue,\n                arrayDiffObject(array, newValue, array.length, 1, [])\n            ];\n        }\n\n        return [array, null];\n    },\n\n    $removeAt(container, propertyName, index) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $removeAt command on non array object is forbidden.');\n        }\n\n        if (index >= array.length || index < 0) {\n            return [array, null];\n        }\n\n        let newValue = array.slice(0, index).concat(array.slice(index + 1));\n        return [\n            newValue,\n            arrayDiffObject(array, newValue, index, 1, [])\n        ];\n    },\n\n    $remove(container, propertyName, item) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $removeAt command on non array object is forbidden.');\n        }\n\n        let index = indexOf(array, item);\n\n        if (index === -1) {\n            return [array, null];\n        }\n\n        let newValue = array.slice(0, index).concat(array.slice(index + 1));\n        return [\n            newValue,\n            arrayDiffObject(array, newValue, index, 1, [])\n        ];\n    },\n\n    $splice(container, propertyName, [start, deleteCount, ...items]) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $splice command on non array object is forbidden.');\n        }\n\n        let newValue = array.slice(0, start).concat(items).concat(array.slice(start + deleteCount));\n        return [\n            newValue,\n            arrayDiffObject(array, newValue, start, deleteCount, items)\n        ];\n    },\n\n    $map(container, propertyName, callback) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $map command on non array object is forbidden.');\n        }\n\n        let newValue = array.map(callback);\n        return [\n            newValue,\n            diffObject('change', array, newValue)\n        ];\n    },\n\n    $filter(container, propertyName, callback) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $filter command on non array object is forbidden.');\n        }\n\n        let newValue = array.filter(callback);\n        return [\n            newValue,\n            diffObject('change', array, newValue)\n        ];\n    },\n\n    $reduce(container, propertyName, args) {\n        let array = container[propertyName];\n\n        if (!Array.isArray(array)) {\n            throw new Error('Usage of $reduce command on non array object is forbidden.');\n        }\n\n        // .reduce(callback) : .reduce(callback, initialValue)\n        let newValue = typeof args === 'function' ? array.reduce(args) : array.reduce(...args);\n        return [\n            newValue,\n            diffObject('change', array, newValue)\n        ];\n    },\n\n    $merge(container, propertyName, extensions) {\n        let target = container[propertyName] || {};\n        let newValue = clone(target);\n        let diff = {};\n        for (let key in extensions) {\n            if (extensions.hasOwnProperty(key)) {\n                let newPropertyValue = extensions[key];\n                let oldPropertyValue = target[key];\n                if (newPropertyValue !== oldPropertyValue) {\n                    newValue[key] = newPropertyValue;\n                    let changeType = target.hasOwnProperty(key) ? 'change' : 'add';\n                    diff[key] = diffObject(changeType, oldPropertyValue, newPropertyValue);\n                }\n            }\n        }\n\n        return [newValue, diff];\n    },\n\n    $defaults(container, propertyName, defaults) {\n        let target = container[propertyName];\n        let newValue = clone(target);\n        let diff = {};\n        for (let key in defaults) {\n            if (defaults.hasOwnProperty(key) && newValue[key] === undefined) {\n                newValue[key] = defaults[key];\n                diff[key] = diffObject('add', undefined, defaults[key]);\n            }\n        }\n\n        return [newValue, diff];\n    },\n\n    $apply(container, propertyName, factory) {\n        let newValue = factory(container[propertyName]);\n        return [\n            newValue,\n            diffObject(container.hasOwnProperty(propertyName) ? 'change' : 'add', container[propertyName], newValue)\n        ];\n    },\n\n    $omit(container, propertyName, assert) {\n        let value = container[propertyName];\n\n        if (assert === true || (typeof assert === 'function' && assert(value))) {\n            return [\n                OMIT_THIS_PROPERTY,\n                diffObject('remove', value, undefined)\n            ];\n        }\n\n        return [value, null];\n    },\n\n    $composeBefore(container, propertyName, before) {\n        let fn = container[propertyName];\n\n        if (typeof fn !== 'function') {\n            throw new Error('Usage of $composeBefore command on non function object is forbidden.');\n        }\n\n        if (typeof before !== 'function') {\n            throw new Error('Passing non function object to $composeBefore command is forbidden');\n        }\n\n        let newValue = (...args) => fn(before(...args));\n        return [\n            newValue,\n            diffObject('change', fn, newValue)\n        ];\n    },\n\n    $composeAfter(container, propertyName, after) {\n        let fn = container[propertyName];\n\n        if (typeof fn !== 'function') {\n            throw new Error('Usage of $composeAfter command on non function object is forbidden.');\n        }\n\n        if (typeof after !== 'function') {\n            throw new Error('Passing non function object to $composeAfter command is forbidden');\n        }\n\n        let newValue = (...args) => after(fn(...args));\n        return [\n            newValue,\n            diffObject('change', fn, newValue)\n        ];\n    }\n};\n\n/**\n * @private\n */\nexport let availableCommandKeys = Object.keys(availableCommands);\n\n/**\n * @private\n */\nexport let availableCommandNames = availableCommandKeys.map(key => key.slice(1));\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file update helper module\n * @author otakustay\n */\n\nimport {find, notEmpty} from './util';\nimport {availableCommands, availableCommandKeys, OMIT_THIS_PROPERTY} from './command';\n\n/**\n * 根据提供的指令更新一个对象，返回更新后的新对象及差异对象，原对象不会作任何的修改\n *\n * 现有支持的指令包括：\n *\n * - `$set`：修改指定的属性值\n * - `$push`：向类型为数组的属性尾部添加元素\n * - `$unshift`：向类型为数组的属性头部添加元素\n * - `$pop`：移除类型为数组的属性的尾部元素\n * - `$shift`：移除类型为数组的属性的头部元素\n * - `$removeAt`：移除类型为数组的属性的指定位置的元素\n * - `$remove`：移除类型为数组的属性的指定元素，使用`===`判等且仅移除第一个遇到的元素\n * - `$splice`：通过索引、移除数目、插入元素操作类型为数组的属性\n * - `$map`：对类型为数组的属性进行`map`操作\n * - `$filter`：对类型为数组的属性进行`filter`操作\n * - `$reduce`：对类型为数组的属性进行`reduce`操作\n * - `$merge`：将2个对象进行浅合并（不递归）\n * - `$defaults`：将指定对象的属性值填到原属性为'undefined`的'性上\n * - `$apply`：用一个工厂函数的返回值作为`$set`指令的输入，工厂函数接受属性的旧值作为唯一的参数\n * - `$omit`：用于移除某个属性，传递`boolean`值来确认是否移除（`true`为移除），也可传递一个函数（参数为旧值）用其返回值确认是否移除\n * - `$composeBefore`：组合类型为函数的属性为一个新的函数，新函数首先调用compose提供的函数，随后调用原函数\n * - `$composeAfter`：组合类型为函数的属性为一个新的函数，新函数首先调用原函数，随后调用compose提供的函数\n *\n * 可以在一次更新操作中对不同的属性用不同的指令：\n *\n * ```javascript\n * import {withDiff} from 'san-update';\n *\n * let [newObject, diff] = withDiff(\n *     source,\n *     {\n *         foo: {bar: {$set: 1}},\n *         alice: {$push: 1},\n *         tom: {jack: {$set: {x: 1}}\n *     }\n * );\n * ```\n *\n * @param {Object} source 待更新的对象\n * @param {Object} commands 用于更新的指令\n * @return {[Object, Object]} 返回一个Tuple数组，其中第1项为更新结果，第2项为差异对象\n */\nexport let withDiff = (source, commands) => {\n    // 如果根节点就是个指令，那么直接对输入的对象进行操作，不需要再遍历属性了\n    let possibleRootCommand = find(availableCommandKeys, key => commands.hasOwnProperty(key));\n    if (possibleRootCommand) {\n        let wrapper = {source};\n        let commandValue = commands[possibleRootCommand];\n        return availableCommands[possibleRootCommand](wrapper, 'source', commandValue);\n    }\n\n    // ({string} key) => [newValue, diff]\n    let executeCommand = key => {\n        let propertyCommand = commands[key];\n        let availableCommand = find(availableCommandKeys, key => propertyCommand.hasOwnProperty(key));\n\n        // 找到指令节点后，对当前属性进行更新，\n        // 如果这个节点不代表指令，那么肯定它的某个属性（或子属性）是指令，继续递归往下找\n        return availableCommand\n            ? availableCommands[availableCommand](source, key, propertyCommand[availableCommand])\n            : withDiff(source[key] || {}, propertyCommand);\n    };\n\n    // 因为可能通过指令增加一些原本没有的属性，所以最后还要对`commands`做一次遍历来确保没有漏掉\n    let patchNewProperties = (result, diff) => {\n        for (let key in commands) {\n            if (result.hasOwnProperty(key) || !commands.hasOwnProperty(key)) {\n                continue;\n            }\n\n            let [newValue, propertyDiff] = executeCommand(key);\n            // 理论上因为全是新属性，所以这里的`propertyDiff`不可能是空的\n            diff[key] = propertyDiff;\n\n            if (newValue !== OMIT_THIS_PROPERTY) {\n                result[key] = newValue;\n            }\n        }\n\n        return [result, diff];\n    };\n\n    if (Array.isArray(source)) {\n        let result = [];\n        let diff = {};\n        for (let i = 0; i < source.length; i++) {\n            // 没有对应的指令，自然是不更新的，直接复制过去\n            if (!commands.hasOwnProperty(i)) {\n                result.push(source[i]);\n                continue;\n            }\n\n            let [newValue, propertyDiff] = executeCommand(i);\n            if (notEmpty(propertyDiff)) {\n                diff[i] = propertyDiff;\n            }\n            if (newValue !== OMIT_THIS_PROPERTY) {\n                result.push(newValue);\n            }\n        }\n\n        return patchNewProperties(result, diff);\n    }\n\n    let result = {};\n    let diff = {};\n    for (let key in source) {\n        // 没有对应的指令，自然是不更新的，直接复制过去\n        if (!commands.hasOwnProperty(key)) {\n            result[key] = source[key];\n            continue;\n        }\n\n        let [newValue, propertyDiff] = executeCommand(key);\n        if (notEmpty(propertyDiff)) {\n            diff[key] = propertyDiff;\n        }\n        if (newValue !== OMIT_THIS_PROPERTY) {\n            result[key] = newValue;\n        }\n    }\n\n    return patchNewProperties(result, diff);\n};\n\n/**\n * 根据提供的指令更新一个对象，返回更新后的新对象，原对象不会作任何的修改\n *\n * 具体详情参考`withDiff`的文档\n *\n * ```javascript\n * import {update} from 'san-update';\n *\n * let newObject = withDiff(\n *     source,\n *     {\n *         foo: {bar: {$set: 1}},\n *         alice: {$push: 1},\n *         tom: {jack: {$set: {x: 1}}\n *     }\n * );\n * ```\n *\n * @param {Object} source 待更新的对象\n * @param {Object} commands 用于更新的指令\n * @return {Object} 更新后的对象\n */\nexport let update = (source, commands) => withDiff(source, commands)[0];\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file parse property name\n * @author otakustay\n */\n\nconst LEFT_SQUARE_BRACKET = '['.charCodeAt(0);\n\nexport default source => {\n    if (Array.isArray(source)) {\n        return source;\n    }\n\n    // 这个简易的非状态机的实现是有缺陷的\n    // 比如 a['dd.cc'].b 这种就有问题了，不过我们不考虑这种场景\n    let terms = (source + '').split('.');\n    let result = [];\n\n    for (let i = 0; i < terms.length; i++) {\n        let term = terms[i];\n        let propAccessorStart = term.indexOf('[');\n\n\n        if (propAccessorStart >= 0) {\n            if (propAccessorStart > 0) {\n                result.push(term.slice(0, propAccessorStart));\n                term = term.slice(propAccessorStart);\n            }\n\n            while (term.charCodeAt(0) === LEFT_SQUARE_BRACKET) {\n                let propAccessorEnd = term.indexOf(']');\n                if (propAccessorEnd < 0) {\n                    throw new Error('Property path syntax error: ' + source);\n                }\n\n                let propAccessorLiteral = term.slice(1, propAccessorEnd);\n                if (/^[0-9]+$/.test(propAccessorLiteral)) {\n                    // for number\n                    result.push(+propAccessorLiteral);\n                }\n                else if (/^(['\"])([^\\1]+)\\1$/.test(propAccessorLiteral)) {\n                    // for string literal\n                    result.push((new Function('return ' + propAccessorLiteral))());\n                }\n                else {\n                    throw new Error('Property path syntax error: ' + source);\n                }\n\n                term = term.slice(propAccessorEnd + 1);\n            }\n        }\n        else {\n            result.push(term);\n        }\n    }\n\n    return result;\n};\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file shortcut functions\n * @author otakustay\n */\n\nimport {update} from './update';\nimport parseName from './parseName';\n\nlet buildPathObject = (propertyName, value) => {\n    if (propertyName == null) {\n        return value;\n    }\n\n    let path = parseName(propertyName);\n\n    let result = {};\n    let current = result;\n    for (let i = 0; i < path.length - 1; i++) {\n        current = current[path[i]] = {};\n    }\n    current[path[path.length - 1]] = value;\n    return result;\n};\n\n/**\n * 针对`$set`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Object} 更新后的新对象\n */\nexport let set = (source, path, value) => update(source, buildPathObject(path, {$set: value}));\n\n/**\n * 针对`$push`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Object} 更新后的新对象\n */\nexport let push = (source, path, value) => update(source, buildPathObject(path, {$push: value}));\n\n/**\n * 针对`$unshift`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Object} 更新后的新对象\n */\nexport let unshift = (source, path, value) => update(source, buildPathObject(path, {$unshift: value}));\n\n/**\n * 针对`$pop`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {boolean|Function} assert 用于确认是否要移除属性的判断条件或函数\n * @return {Object} 更新后的新对象\n */\nexport let pop = (source, path, assert) => update(source, buildPathObject(path, {$pop: assert}));\n\n/**\n * 针对`$shift`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {boolean|Function} assert 用于确认是否要移除属性的判断条件或函数\n * @return {Object} 更新后的新对象\n */\nexport let shift = (source, path, assert) => update(source, buildPathObject(path, {$shift: assert}));\n\n/**\n * 针对`$removeAt`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {number} index 需要删除的索引\n * @return {Object} 更新后的新对象\n */\nexport let removeAt = (source, path, index) => update(source, buildPathObject(path, {$removeAt: index}));\n\n/**\n * 针对`$remove`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 需要删除的值\n * @return {Object} 更新后的新对象\n */\nexport let remove = (source, path, value) => update(source, buildPathObject(path, {$remove: value}));\n\n/**\n * 针对`$splice`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {number} start 插入起始位置\n * @param {number} deleteCount 删除的元素个数\n * @param {...*} items 插入的元素\n * @return {Object} 更新后的新对象\n */\nexport let splice = (source, path, start, deleteCount, ...items) => {\n    let args = [start, deleteCount, ...items];\n    return update(source, buildPathObject(path, {$splice: args}));\n};\n\n/**\n * 针对`$map`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} callback 回调函数\n * @return {Object} 更新后的新对象\n */\nexport let map = (source, path, callback) => update(source, buildPathObject(path, {$map: callback}));\n\n/**\n * 针对`$filter`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} callback 回调函数\n * @return {Object} 更新后的新对象\n */\nexport let filter = (source, path, callback) => update(source, buildPathObject(path, {$filter: callback}));\n\n/**\n * 针对`$reduce`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {...*} args 调用`reduce`时的参数，可以为`{Function} callback`或`{Function} callback, {*} initialValue`\n * @return {Object} 更新后的新对象\n */\nexport let reduce = (source, path, ...args) => {\n    let command = args.length === 1 ? {$reduce: args[0]} : {$reduce: args};\n    return update(source, buildPathObject(path, command));\n};\n\n/**\n * 针对`$merge`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Object} 更新后的新对象\n */\nexport let merge = (source, path, value) => update(source, buildPathObject(path, {$merge: value}));\n\n/**\n * 针对`$defaults`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {*} value 用于更新的值\n * @return {Object} 更新后的新对象\n */\nexport let defaults = (source, path, value) => update(source, buildPathObject(path, {$defaults: value}));\n\n/**\n * 针对`$apply`指令的快捷函数\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} factory 用于生成新值的工厂函数\n * @return {Object} 更新后的新对象\n */\nexport let apply = (source, path, factory) => update(source, buildPathObject(path, {$apply: factory}));\n\n/**\n * 针对`$omit`指令的快捷函数，其中`assert`参数默认值为`true`\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {boolean|Function} assert 用于确认是否要移除属性的判断条件或函数\n * @return {Object} 更新后的新对象\n */\nexport let omit = (source, path, assert = true) => update(source, buildPathObject(path, {$omit: assert}));\n\n/**\n * 针对`$omit`指令的快捷函数，其中`assert`参数默认值为`true`\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} before 包装函数，该函数会在原函数前执行，且返回值传递给原函数作为参数\n * @return {Object} 更新后的新对象\n */\nexport let composeBefore = (source, path, before) => update(source, buildPathObject(path, {$composeBefore: before}));\n\n/**\n * 针对`$omit`指令的快捷函数，其中`assert`参数默认值为`true`\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组，\n *     如果该参数为'undefined`或`null`，则会直接对`source`对象进行更'操作\n * @param {Function} after 包装函数，该函数会在原函数后执行，且接收原函数返回值作为参数\n * @return {Object} 更新后的新对象\n */\nexport let composeAfter = (source, path, after) => update(source, buildPathObject(path, {$composeAfter: after}));\n\n/**\n * 支持通过依赖计算属性值的更新快捷函数\n *\n * 此函数仅有快捷方式，在`update`函数时不能使用此指令\n *\n * 此函数必须指定`path`参数，不能直接对对象本身使用\n *\n * @param {Object} source 待更新的对象\n * @param {string?|Array.<string>|number?|Array.<number>} path 属性的路径，如果更新二层以上的属性则需要提供一个字符串数组\n * @param {Function|Array.<Function>} selectors 用于获取`factory`的依赖参数的函数，每个函数返回一个值作为`factory`的参数\n * @param {Function} factory 用于生成新值的工厂函数，该函数前n个参数是`selectors`参数的返回值，最后一个参数为需要更新的属性的当前值\n * @return {Object} 更新后的新对象\n */\nexport let applyWith = (source, path, selectors, factory) => {\n    if (Array.isArray(selectors)) {\n        let dependencies = selectors.map(select => select(source));\n        let boundFactory = value => factory(...dependencies, value);\n        return apply(source, path, boundFactory);\n    }\n\n    let dependency = selectors(source);\n    let boundFactory = value => factory(dependency, value);\n    return apply(source, path, boundFactory);\n};\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file chainning wrap\n * @author otakustay\n */\n\nimport {update, withDiff} from './update';\nimport {availableCommandNames} from './command';\nimport {merge} from './shortcut';\n\nconst EMPTY_COMMANDS = {};\n\nlet createUpdater = (value, commands) => availableCommandNames.reduce(\n    (updater, shortcut) => {\n        updater[shortcut] = (path, ...args) => {\n            let additionCommand = {['$' + shortcut]: args.length === 1 ? args[0] : args};\n            let newCommands = merge(commands, path, additionCommand);\n            return createUpdater(value, newCommands);\n        };\n        return updater;\n    },\n    {\n        value() {\n            return update(value, commands);\n        },\n\n        withDiff() {\n            return withDiff(value, commands);\n        }\n    }\n);\n\n/**\n * 包装一个对象为可链式调用更新的对象\n *\n * 包装后的对象带有所有更新快捷方式，同时使用`value()`可获取更新后的值\n *\n * @param {Object} source 包装的对象\n * @return {Object} 可执行所有用于更新的命令\n */\nexport default source => createUpdater(source, EMPTY_COMMANDS);\n","/**\n * san-update\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file macro builder\n * @author otakustay\n */\n\nimport {update, withDiff} from './update';\nimport {availableCommandNames} from './command';\nimport {merge} from './shortcut';\n\nlet createMacro = commands => availableCommandNames.reduce(\n    (macro, shortcut) => {\n        macro[shortcut] = (path, ...args) => {\n            let additionCommand = {['$' + shortcut]: args.length === 1 ? args[0] : args};\n            let newCommands = merge(commands, path, additionCommand);\n            return createMacro(newCommands);\n        };\n        return macro;\n    },\n    {\n        build() {\n            let result = value => update(value, commands);\n            result.withDiff = value => withDiff(value, commands);\n            return result;\n        },\n\n        buildWithDiff() {\n            return value => withDiff(value, commands);\n        }\n    }\n);\n\nconst INITIAL_MACRO = createMacro({});\n\n/**\n * 包装一个更新指令为Macro\n *\n * 一个Macro带有所有更新的快捷方式，每一次调用都会生成一个新的Macro，最终使用`build()`可以生成一个包含所有指令的更新对象的函数。\n *\n * @return {Object} 包含所有更新快捷方式的Macro\n */\nexport default () => INITIAL_MACRO;\n"]}